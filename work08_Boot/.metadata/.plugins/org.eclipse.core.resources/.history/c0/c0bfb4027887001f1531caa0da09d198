package com.web.spring.repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;

import com.web.spring.entity.Custom;

/*
  이곳은 Spring Data JPA Repository 이다.
  이전의 DAO와 같은 역할을 한다.
  원래 인터페이스가 나오면 해당 인터페이스를 구현한 실체 클래스를 다시 상속 받아 작성해야 하지만 
  Spring Data JPA 기술은 인터페이스를 구현하는 빈 클래스를 자동으로 생성시켜준다.
  
  JpaRepository<객체, 객체의 PK>
 */
public interface CustomRepository extends JpaRepository<Custom, Integer> {

	// 아무것도 작성 안해도 기본적인 CRUD가 다 들어있다.
	// JpaRepository가 물려준다.
	
	// JPA Query Method 추가해보자
	/*
		1. 대부분 findBy로 시작한다.
		2. 이름 규칙만 잘 정해주면 자동으로 SQL 구문이 실행된다.
		3. ORM 방식이기에 함수명은 CamelCase가 기본으로 지켜져야 한다.
		4. 반환 타입은 내 마음대로 사용한다.
		
	*/
	
	Optional<List<Custom>> findByName(String name);
	
	//findByLastnameAndFirstname
	Optional<Custom> findByLastnameAndFirstname(String name, String email);
	
	//findByLastnameOrFirstname
	List<Custom> findByNameOrEmail(String name, String email);
	
	//고객의 id 값이 1~3 사이의 아이디를 가지는 고객을 검색
	List<Custom> findByCustomIdBetween(int startId, int endId);
	
	//고객의 id가 3보다 작은 아이디를 가지는 고객을 검색
	List<Custom> findByCustomIdLessThan(int customId);
	
	//고객의 등록일자가 어제 이후로 등록한 고객을 검색
	List<Custom> findByRegDateAfter (LocalDateTime yesterday);
	List<Custom> findByRegDateBefore (LocalDateTime yesterday);
	
	//고객의 이름이 null 값인 고객을 검색
	List<Custom> findByNameIsNull();
	List<Custom> findByNameIsNotNull();
	
	//고객 이름이 name인 고객을 검색 (단 와이들 카드 적용 안됨)
	//SELECT * FROM custom WHERE name like ?;
	List<Custom> findByNameLike(String name); // 값에다 %, _ 지정해야 한다.
	
	//SELECT * FROM custom WHERE name like "%종각";
	List<Custom> findByNameEndingWith(String name);
	
	//findByAgeOrderByLastnameDesc
	List<Custom> findByOrderByCustomIdDesc();
	List<Custom> findByOrderByCustomId();
	
	//고객 id가 3보다 큰 아이디를 가지는 고객을 검색 + 아이디를 내림차순으로 정렬
	//findByAgeGreaterThan
	List<Custom> findByCustomIdGreaterThanAndOrderByCustomIdDesc(int customId );
	
}
