package com.web.spring;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import com.web.spring.entity.Board;
import com.web.spring.repository.BoardRepository;
import com.web.spring.repository.CustomRepository;
import com.web.spring.repository.RoleRepository;

import jakarta.transaction.Transactional;

@SpringBootApplication
public class Boot06JpaEntitiesApplication implements CommandLineRunner{
	
	@Autowired
	RoleRepository rolRepository;
	
	@Autowired
	CustomRepository customRepository;
	
	@Autowired
	BoardRepository boardRepository;
	
	@Override
	@Transactional
	public void run(String... args) throws Exception {
		
		//1. 모든 Role 정보를 받아온다.
//		rolRepository.findAll() .forEach(r->System.out.println(r));
		
		//2. 모든 Custom 정보를 받아온다.
//		customRepository.findAll() 
//						.forEach(c->System.out.println(c));
		
		//고객정보도 함께 가져오자
		/* [N(고객수) + 1(전체고객 select) 문제 발생!!]
		 * findAll() -> select * from custom; // 한번의 쿼리로 전체 Custom을 받아온다.
		 * c.getRoles()	-> select * from custom_role join role where custom_id=? : id 개수만큼 돈다.  
		 * 
		 * 이런 문제를 N+1 문제라고 한다.
		 * 만약 Custom 레코드 수가 많다면 심각한 성능 저하에 빠진다.
		 * 
		 * 연관관계가 설정된 엔터티를 조회할 경우, findAll로 조회할 경우, 데이터의 개수(N)개 만큼 조인 select 절이 계속 실행된다.
		 * 
		 * Custom 테이블의 Role 정보를 받아오기 위해 
		 * Custom -- custom_role -- role 여기 안에 있는 데이터를 한번의 쿼리문으로 받아올 수 없을까..?
		 * 
		 * 
		 */
		
//		customRepository.findAll()		
//						.forEach(c->{
//							System.out.println(c);
//							System.out.println(c.getRoles());
//							System.out.println("==========");
//						});
		
		
		//3. 모든 Board 정보를 받아오자 (N+1 문제 발생)
		//board만 요청했는데 Custom까지도 나옴
		//findAll()에서는 Board 정보만 받아오고 싶지만 fetchType이 Eager이기에 연관된 모든 것이 나온다. Lazy로 변경하자.
//		boardRepository.findAll()
//						.forEach(b->System.out.println(b));
	
		//게시글 정보와 함께 Custom 정보도 받고 싶을때,
//		boardRepository.findAll()
//						.forEach(b->{
//							System.out.println(b);
//							System.out.println(b.getCustom());
//							System.out.println("==========================================================================");
//						});
		
		
		//find로 하나만 받을 때, Lazy와 Eager를 비교해보자
		//Board board =(boardRepository.findById(1l).get();
		Board board =(boardRepository.findById(1l).orElseThrow());
		System.out.println(board);
		System.out.println(board.getCustom());
		
		
		/*
		 * findAll인 경우 fetchType 이 Eager, Lazy 방식이든 조인이 안 걸린다.
		 * 그러나, 한 건의 데이터를 가져오는 findById인 경우, 
		 * Eager 방식에서 left join이 발생한다.
		 * 
		 * 전체 검색/ 한 건 검색이 서로 다르게 동작한다.
		 * Entity가 결합된 관계에서 굳이 함께 가져와야 할 필요가 없는 경우, Lazy 방식을 가져와야 성능이 좋아진다. 
		 * 반면에, 데이터를 함께 가져와야 하는 경우(게시판 글 정보 + 글쓴이 정보), 특히 한 건의 데이터를 직접적으로 받아와야 하는 경우에는 Eager 방식을 사용해야 성능이 좋아진다.
		 * 
		 */
		
	}

	
	public static void main(String[] args) {
		SpringApplication.run(Boot06JpaEntitiesApplication.class, args);
	}

}
